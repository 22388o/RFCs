<pre>
  State: draft
  Created: 2021-2-17
</pre>

# 07. Cryptographic Setup

## Overview

This RFC specifies the cryptographic primitives used to transfer secrets through transactions with adaptor signatures and specifies the cryptographic setup required at the beginning of a swap to guarantee funds safety and recovery. Key, signature, and proof formats are dependent on the blockchain and the type of cryptography used, see [08. Transactions](./08-transactions.md) for more examples with Bitcoin.

## Table of Contents

  * [Cryptographic Keys](#cryptographic-keys)
    * [Alice](#alice)
    * [Bob](#bob)
    * [Signatures](#signatures)
  * [Adaptor Signatures](#adaptor-signatures)
    * [ECDSA Scripts](#ecdsa-scripts)
    * [Taproot Schnorr Scripts](#taproot-schnorr-scripts)
  * [Cross-group Discrete Logarithm Proof](#cross-group-discrete-logarithm-proof)
  * [References](#references)

## Cryptographic Keys

We describe the cryptographic keys needed by both swap roles defined in [01. High Level Overview](./01-high-level-overview.md).

A `private_key` type and a `public_key` type is defined for the arbitrating blockchain for each cryptographic approaches and for the accordant blockchain.

For each public key describe in the following section we assume the knowledge of the corresponding private key.

**Arbitrating example:** for Bitcoin ECDSA the `public_key` is an ECDSA `secp256k1` public key, and for Bitcoin Schnorr the `public_key` is a Schnorr `secp256k1` public key.

**Accordant example:** for Monero the `public_key` is an `ed25519` public key.

### Alice

Keys generated by Alice role at the beginning of the swap phase:

```
Ab: arbitrating buy public_key;
Ac: arbitrating cancel public_key;
Ar: arbitrating refund public_key;
Ap: arbitrating punish public_key;

Ta: arbitrating adaptor public_key;

K_s^a: accordant spend public_key;
K_v^a: accordant view public_key;

where
    Ta = K_s^a projection over the arbitrating group
```

### Bob

Keys generated by Bob role at the beginning of the swap phase:

```
Bf: arbitrating fund public_key;
Bb: arbitrating buy public_key;
Bc: arbitrating cancel public_key;
Br: arbitrating refund public_key;

Tb: arbitrating adaptor public_key;

K_s^b: accordant spend public_key;
K_v^b: accordant view public_key;

where
    Tb = K_s^b projection over the arbitrating group
```

### Signatures

We define a `signature` type for the arbitrating blockchain role related to the `private_key`/`public_key` types defined previously.

**Arbitrating example:** for Bitcoin ECDSA the `signature` is an ECDSA signature, and for Bitcoin Schnorr the `signature` is a Schnorr signature following [[2] BIP 0340: Schnorr Signatures for secp256k1](#references).

## Adaptor Signatures

We describe an adaptor signature interface and two instantiations, one for ECDSA inside Bitcoin scripts and one for Schnorr inside Taproot scripts.

An adaptor signature scheme extends a standard signature (`Gen`, `Sign`, `Vrfy`) scheme with:

 * `EncGen`: An encryption key generation algorithm, in this protocol the encryption key generation is linked to the cross-group DLEQ proof.

 * `EncSig`: Encrypt a signature and return an adaptor signature. This RFC uses the public key tweaking method.

 * `EncVrfy`: Verify an adaptor signature based on public parameters, if validation passes the decrypted adaptor signature is a valid signature.

 * `DecSig`: Decrypt an adaptor signature by injecting the encryption key.

 * `RecKey`: Recover the key material needed for extracting the encryption key with `Rec`.

 * `Rec`: Recover the encryption key based on the adaptor signature and the decrypted signature.

### ECDSA Scripts

 * `EncSig`:

```
 pi = PDLEQ( (G, R'), (T, R), k )
 s' = k^-1 ⋅ ( hash(m) + f(R)d )

 return (R, R', s', pi)

where
    f(): x-coordinate mod q
    P = dG
    R = kT
    R' = kG
```

`PDLEQ` produces a zero-knowledge proof of knowledge of the same relation `k` between two pairs of elements in the same group, i.e. `(G, R')` and `(T, R)`.

 * `EncVrfy`:

```
 VDLEQ( (G, R'), (T, R), pi ) =? 1

 R' =? ( H(m)G ⋅ f(R)P )^{s'^-1}

where
    f(): x-coordinate mod q
    P = dG
    R = kT
    R' = kG
```

`VDLEQ` verifies a zero-knowledge proof of knowledge of the same unknown relation `x` between two pairs of elements in the same group.

 * `DecSig`:

```
 s = s't^-1
   = k^-1 ⋅ ( hash(m) + f(R)d ) ⋅ t^-1

 return (f(R), s)

where
    f(): x-coordinate mod q
    P = dG
    R = kT
    R' = kG
```

 * `Rec`:

```
 t' = s^-1 ⋅ s'

      /  s' if s'G = T
 t = |  -s' if s'G = T^-1
      \  NaN otherwise
```

### Taproot Schnorr Scripts

This notation follows BIP 340, with some simplication on even y coordinate check for private keys:

 * `EncSig`:

```
 s' = k + tagged_hash( bytes(R + T) || bytes(P) || m )d
```

 * `EncVrfy`:

```
 s'G =? R + tagged_hash( bytes(R + T) || bytes(P) || m )P

where
    P = dG
```

 * `DecSig`:

```
 s = s' + t
   = k + t + tagged_hash( bytes(R + T) || bytes(P) || m )d

where
    P = dG
    R = kG
    T = tG
```

 * `Rec`:

```
 t = s - s'
```

BIP 340 Schnorr:

 * `Vrfy`:

```
 sG =? R + tagged_hash( bytes(R) || bytes(P) || m )P
```

## Cross-group Discrete Logarithm Proof

TODO

## References

 * [[1] One-Time Verifiably Encrypted Signatures A.K.A. Adaptor Signatures](https://github.com/LLFourn/one-time-VES/blob/master/main.pdf)
 * [[2] BIP 0340: Schnorr Signatures for secp256k1](https://en.bitcoin.it/wiki/BIP_0340)

